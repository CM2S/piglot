"""Driver script for piglot."""
import os
import os.path
import time
import argparse
import shutil
from yaml import safe_dump
import piglot.losses
import piglot.optimisers
from piglot.optimisers.optimiser import StoppingCriteria
from piglot.links import LinksLoss
from piglot.yaml_parser import parse_parameters, parse_case, parse_optimiser, parse_config_file, parse_objective



def default_output_dir():
    """Return the default output directory name.

    Returns
    -------
    str
        Directory name
    """
    return time.strftime("piglot-%Y-%m-%d-%Hh%M")



def parse_args():
    """Parse command line arguments of the script.

    Returns
    -------
    argparse.Namespace
        Parsed arguments
    """
    # Global argument parser settings
    parser = argparse.ArgumentParser(
        prog='piglot',
        description='Parameter identification toolbox',
    )

    # Argument groups
    config_group = parser.add_argument_group(
        title='Configuration file',
        description='When using a configuration file, the following options are available'
    )
    command_group = parser.add_argument_group(
        title='Command line arguments',
        description='When using a commmand line arguments, the following options are available'
    )

    # Add arguments: configuration file group
    config_group.add_argument(
        'config',
        default=None,
        nargs='?',
        type=str,
        help='Configuration file to use',
    )

    # Add arguments: command line group
    command_group.add_argument(
        '--input',
        type=str,
        help='Input file path for LINKS',
    )
    command_group.add_argument(
        '--field',
        nargs=2,
        type=str,
        help=("Output field to use for comparison. SOURCE must be either Reaction or OutFile. "
              "For reactions, FIELD must be x, y or z. "
              "For out files, FIELD must be the column name to use."
              "For both cases, the load factor will be used as time."),
        metavar=('SOURCE', 'FIELD')
    )
    command_group.add_argument(
        '--reference',
        type=str,
        help=("Reference file. Must be a two-column file where the first is the load factor "
              "and the second is the specified output field."),
    )
    command_group.add_argument(
        '--optimiser',
        choices=piglot.optimisers.names(),
        help='Name of the optimiser to use',
    )
    command_group.add_argument(
        '--iters', '--iter',
        type=int,
        help='Maximum number of iterations',
    )
    command_group.add_argument(
        '--loss',
        choices=piglot.losses.names(),
        help='Name of the loss to use',
    )
    command_group.add_argument(
        '--links',
        default="LINKS",
        type=str,
        help='Path for LINKS binary',
    )
    command_group.add_argument(
        '--conv_tol',
        default=None,
        type=float,
        help='Loss convergence tolerance',
    )
    command_group.add_argument(
        '--max_func_calls',
        default=None,
        type=int,
        help='Maximum number of function calls',
    )
    command_group.add_argument(
        '--max_iters_no_improv',
        default=None,
        type=int,
        help='Maximum iterations without improvement',
    )
    command_group.add_argument(
        '--output',
        default=default_output_dir(),
        type=str,
        help='Directory to place output files',
    )
    command_group.add_argument(
        '--tmp_dir',
        default=None,
        type=str,
        help='Temporary directory to run analyses',
    )
    command_group.add_argument(
        '--quiet',
        action='store_true',
        help='If given, no terminal output is produced',
    )

    return parser.parse_args()



def get_config_dict(args):
    if args.config:
        config = parse_config_file(args.config)
    else:
        # Check that required arguments have been passed
        if args.loss is None:
            raise RuntimeError("Loss has not been passed")
        if args.iters is None:
            raise RuntimeError("Number of iterations has not been passed")
        if args.input is None:
            raise RuntimeError("Input file has not been passed")
        if args.field is None:
            raise RuntimeError("Output fields have not been passed")
        if args.reference is None:
            raise RuntimeError("Reference file has not been passed")
        if args.optimiser is None:
            raise RuntimeError("Optimiser has not been passed")
        # Build configuration dict
        config = {
            "links": args.links,
            "iters": args.iters,
            "conv_tol": args.conv_tol,
            "max_func_calls": args.max_func_calls,
            "max_iters_no_improv": args.max_iters_no_improv,
            "optimiser": args.optimiser,
            "output": args.output,
            "tmp_dir": args.tmp_dir,
            "quiet": args.quiet,
            "cases": {
                args.input: {
                    "loss": args.loss,
                    "fields": [
                        {
                            "type": args.field[0],
                            "field": args.field[1],
                            "reference": args.reference
                        }
                    ]
                }
            }
        }
    # Sanitise remaining fields
    if config["conv_tol"] is not None:
        config["conv_tol"] = float(config["conv_tol"])
    if config["max_func_calls"] is not None:
        config["max_func_calls"] = int(config["max_func_calls"])
    if config["max_iters_no_improv"] is not None:
        config["max_iters_no_improv"] = int(config["max_iters_no_improv"])
    return config



def main():
    args = parse_args()
    config = get_config_dict(args)
    # Build output directory with a copy of the configuration file
    output_dir = config["output"]
    if os.path.isdir(output_dir):
        shutil.rmtree(output_dir)
    os.makedirs(output_dir, exist_ok=True)
    with open(os.path.join(output_dir, "config"), 'w', encoding='utf8') as file:
        safe_dump(config, file)
    # Build piglot problem
    parameters = parse_parameters(config)
    optimiser = parse_optimiser(config["optimiser"])
    objective = parse_objective(config["objective"], parameters, output_dir)
    stop = StoppingCriteria(conv_tol=config["conv_tol"],
                            max_func_calls=config["max_func_calls"],
                            max_iters_no_improv=config["max_iters_no_improv"])
    # Run the optimisation
    _, best_params = optimiser.optimise(objective, config["iters"], parameters,
                                        output=output_dir,
                                        verbose=not config["quiet"],
                                        stop_criteria=stop)
    # Re-run the best case
    if 'skip_last_run' not in config:
        objective(parameters.normalise(best_params))



if __name__ == '__main__':
    main()
